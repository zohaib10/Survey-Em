1) what are app.use() calls?
  They wire up middleware
    Middleware: small functions that can be used to modify the requests incoming to our app before they are sent off to route handlers.

//this is what the middleware functions do for us
  Request comes in => cookie-session gets the cookie => passport gets the user id from the cookie => [deserializeUser] unsets the cookie and returns the user => request is sent to proper route handler (which was '/api/logout' in our case)


Lecture # 46
Create a production database and a production google api. Use different accounts so it does not get hacked.

Lecture # 47
  1. Authorized JS Origin for google api: which website or webpage will send the user
  2. Authorized redirect URI: where users are sent After redirection
  3. {heroku open} command in terminal opens up our heroku website
  4. When we deploy our app to heroku, there is an existing NODE_ENV variable that tell us weather we are running in a production environment or not. {if (process.env.NODE_ENV === 'production')}

Lecture # 48
  1. if we are running in heroku NODE_ENV is set to 'production' automatically
  2. In the keys file we use NODE_ENV to find out if we are in production or not and depending on that we require the needed keys file and export it

Lecture # 49
  1. We went to heroku and added configuration variables {googleClientID, googleClientSecret,mongoURI, cookieKey} make sure to remove trailing spaces when pasting those keys
  2. Then we added everything to git {git add .}
  3. Then we committed everything to git {git commit -m "the message"}
  4. Then we pushed everything to heroku {git push heroku master}

Lecture # 50
  1. We want 'https://' not 'http://'
  2. Heroku uses a proxy to ensure that the traffic from our browser is directed to the correct server
  3. googleStrategy does not want to trust requests going through a proxy so it removes the 's' in 'https'
  4. We have to add configuration to tell googleStrategy to trust any proxy that it encounters in between our server and the requests
  5. The other solution is to just spell out the path in the callback path of the google strategy in the passport file
  6. The added configuration is {proxy: true} in the GoogleStrategy

Lecture # 51
    1. Starting on client side
    2. google create-react-app to get documentations for creating a react client side app
    3. install create-react-app globally {sudo npm install -g create-react-app}
    4. when installed make sure you're in your server directory and run {create-react-app client}
    5. that will install more dependencies and will create a react app with the given name

Lecture # 52
  1. The client app has its ow built-in server
  2. if you run the command {npm start} while inside of the client directory. You will be taken to your website?
  3. we have a react server for front-end
  4. the react server takes the component files {app.js, button.js, header.js} and bundles them together using webpack and/or babel and it spits out a bundel.js file that gets loaded up in the browser

Lecture # 53
  1. the package {concurrently} helps us run the two servers {react and express} together
  2. setting up package.json of the backend server to run client by adding this {npm run start --prefix client} to the scrips section of the file
  3. under the scripts section we also had {"dev": "nodemon index.js"} thats why to run our server we would say "npm run dev"
  4. we changed "dev" to "server" now to run server and client concurrently we say {"dev": "concurrently \"npm run server\" \"npm run client\""} sidenote: dev can be called anything does not have to be called dev
  5. To run we just do {npm run dev}

Lecture # 54
  1. adding the link to {app.js}. But if we add an anchor tag {/auth/google} it wont work because we cant use a relative link
  2. So we have to make the link {http://localhost:5000/auth/google} but this will only work with in development environment
  3. To fix this we add {proxy} authentication for {/auth/google} for it to start working perfectly

Lecture # 55
  1. after fixing the relative address thing, if we run the website we get a {redirect_uri_mismatch} because google thinks we are tryig to go back to {localhost:3000}
  2. to fix that we have to add the link as an authorized call back ONLY ON DEVELOPMENT SIDE
  3. We go to our google dev app and add it under the authorized redirect
  4. In production the create-react-app server does not exist

Lecture # 56
  1. Another reason that proxy is needed is because in Dev mode we are at localhost:3000 and making requests to localhost:5000 is like making requests to a different domain {google -> airbnb example}
  2. Proxy makes the browser think that we are still making a request to localhost:3000 and so it includes all of the cookies that it would otherwise take out if we did not use proxy
  3. goes over what the flow of the app would be in dev mode when some one accesses it

Lecture # 60
  1. We have two .js files. {index.js} for {redux} and {app.js} for {React Router} stuff
  2. Install {npm install --save redux react-redux react-router-dom}
  3. started {index.js} this will hold {redux} stuff

Lecture # 61
  1. Naming convention, if an app exports a component we start the name of the file with a capital letter
  2. Because we are dealing with front end, webpack and babel we have access to ES15 modules which allows us to use {import} statements instead of {require} statements
  3. when using the {ReactDOM.render(<App />, document.querySelector('#root'))}. The first arguments is our app in a tag cause its a JSX file and the second argument is {document.querySelector('#root')} found in {public/index.html}

  Lecture # 63
    1. Inside our redux {index.js} file we are going to create a redux store and we are also going to render a provider tag
    2. Provider tag is a react component provided to us by the react-redux library
    3. react-redux library makes sure that react and redux work fine together and provide is the link between them

  Lecture # 64
    1. Started working on reducers -- created authReducer function and will import it into the index.js file in the reducers folder which will then be linked to the redux store

  Lecture # 65
    1. used combineReducers to properly export the authReducers state
    2. imported reducers in our main index.js file
    3. I dont know what authReducer is suppose to do

  Lecture # 66
    1. Spoke about the layout and what the user will see on the page at different points in time
    2. Going to start on react-router to design parts that a user sees during different times

  Lecture # 67
    1. Different components will show on the screen depending on what router the user is currently visiting
    2. React-router displays specific content on the screen based on the router the user is currently at
    3. There are three react-router libraries {1. dom} contains helpers to help modify/navigate the dom
    4. {react-router-native} used with react native
    5. {react-router-core} contains shared info between dom and native
    6. BrowserRouter helper tells the page how to behave
    7. Route helper draws the connection between the route that a user can visit and the components that will be made visible on the screen

Lecture # 68
  1. BrowserRouter can only take one child

Lecture # 69
  1. Start setting routes
  2. The route property exact = {true} ensures that the path matches exactly

Lecture # 75
  1. we will be installing axios library which will help us make ajax request to our express api
  2. redux-thunk helps make async process behave the way we expect them to

Lecture # 81
  1. to hookup a component to redux store
    i. we connect helper from react redux
    ii. we define the map state to props function
    iii. we pull off the pieces of state we care about in Header

Lecture # 86
  1. The link tag is provided by the react router Library
  2. have to import it {done in Header.js }

  Lecture 111:
    1. We are going to tell heroku to install all dependancies 
